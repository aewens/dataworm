#!/usr/bin/env ruby

=begin
    
File:      dwrm
Version:   0.1.0
Author:    Austin Ewens
Created:   07-17-2014
Copyright: 2014, Austin Ewens
Purpose:   A shell utility for a private version control system
    
=end

# $:.unshift(File.expand_path(File.dirname(__FILE__) + "/lib"))
require "fileutils"
require "yaml"
require "digest"

# here = File.expand_path(File.dirname(__FILE__))

#-- Function graveyard
    # hash = rand(36**16).to_s(36)
    # /(\.?\.?(?:\/\w*)*)[^\/]?/
    
# puts "\n+---[ DataWorm ]---+\n\n"

def help_docs
# Documentation for DataWorm

    puts <<-EOF
= dwrm

* Written by Austin Ewens
* Copyright 2014, Austin Ewens


== Description:

DWRM stands for DataWoRM (formerly written as DataWorm)

It is a Private Version Control System (PVCS) that acts as a Git substitute to 
create local repositories on your machine only accessible by you*. The intent 
is to allow for version control while giving you both control and privacy over 
your data.

DataWorm will also not only manage the historical versions of your projects in 
a PVCS fashion, but also make delta backups and temporary restore points 
whenever any destructive action is done to your project to allow for immediate 
restore to the last version that was popped from your repository.

* Refer to Disclaimer


== Disclaimer

DataWorm is strictly an offline service that only manages data locally across 
your drive. No monitoring of any kind is done through legitimate copies of 
DataWorm. All data obtained from your computer by DataWorm does not and will 
not ever be sent outside the scope of your machine unless specified otherwise. 

For any legitimate concerns regarding the disclaimers above, contact me at 
https://github.com/aewens or https://twitter.com/aewens_


== Compatibility

DataWorm intends to add compatibility for Git so that it will not be able to 
accidentally interact with and/or corrupt any of DataWorm's configurations and 
possible backups.


== Usage:

    dwrm [commands] [hash] [flags] [tag]


== Commands

help    :: Print out the documenation you are reading now
init    :: Intialize the .dwrm directory and its configurations
list    :: List all versions in order of occurrence 
push    :: Push a version to your repository
pop     :: Pop a version from your repository
EOF
# revert  :: {hash} -> Takes a version hash as a parameter
#             Revert back to version {hash} from the repository
# undo    :: {num} -> Takes a number as a parameter; Defaults to 1
#             Rollback {num} versions back in the repo's version Stack
# redo    :: Pushes back any versions removed by pop, revert, or undo
# remove  :: Safely remove your project from DataWorm
# restore :: Recreate your project to DataWorm if it was removed
# recover :: Rollback entire repository back to last version if corrupted    
# 
# 
# == Flags
# 
# Options:
#     [-bBeos]
#     [--backup, no-backup, encrypt, offline, ssh]
# 
# backup    :: Call backup when disabled in config
# no-backup :: Negate the effect of default backups
# encrypt   :: Enables encryption on all data for the current project
# offline   :: If using SSH, helps improve speed by skipping online check
# ssh       :: Tell DataWorm to look for your SSH server to store versions
# 
# 
# EOF
end

def directory_exists? dests
# Determine if directory exists
    
    exists = true
    dests.each do |dest|
        exists = false unless File.directory? File.expand_path(dest)
    end
    return exists
end

def set_configs dir
# Push configuration files to .dwrm
    
    
    config = "#{dir}/config.yml"
    File.open config, File::CREAT unless File.file? config
    File.open(config, "w") do |f|
        conf = {}
        conf[:uuid] = 1.upto(8).map{rand(16).to_s(16)}.join("")
        conf[:root] = File.expand_path(File.dirname(__FILE__))
        conf[:last] = "-"
        conf[:here] = dir
        conf[:list] = {} # {time: hash}
        conf[:hist] = "" # last command
        # conf[:time] = Time.now.to_i
        f.write(YAML.dump conf)
    end
    puts File.open(config, "r").read()
end

def dwrm_push here
    curr = here.split("/")[-1]
    root = File.expand_path(File.dirname(__FILE__))
    Dir.chdir ".." do
        break unless directory_exists? ["#{root}/data","#{here}/.dwrm"]
        config = "#{here}/.dwrm/config.yml"
        conf = nil
        conf = File.open(config, "r").read if File.file?(config)
        break if conf.nil?
        uuid = YAML.load(conf)[:uuid]
        
        hash  = Digest::MD5.hexdigest("#{Time.now.to_i}")
        first = false
        repo  = "#{root}/data/#{uuid}"
        unless directory_exists? [repo]
            FileUtils.mkdir_p(repo)
            
            # Create a pseudo last.tar.gz
            cmd  = []
            cmd << "cd #{repo}/"
            cmd << "mkdir last"
            cmd << "touch last/#{hash}"
            cmd << "tar -czf last.tar.gz last/"
            cmd << "rm -rf last/"
            %x[#{cmd.join(";")}]
            
            first = true
        end
        
        uhash = "#{uuid}/#{hash}"
        
        cmd  = []
        cmd << "tar -czf #{curr}.tar.gz #{curr}/"
        cmd << "mv #{curr}.tar.gz #{repo}/"
        %x[#{cmd.join(";")}]
        
        FileUtils.mkdir_p("#{repo}/#{hash}")
        
        c = YAML.load(File.open("#{here}/.dwrm/config.yml", "r").read)
        list = Hash[c[:list].sort]
        File.open(config, "w") do |f|
            c[:list][Time.now.to_i] = hash
            f.write(YAML.dump c)
        end
        
        one = "#{repo}/#{curr}.tar.gz"
        two = "#{repo}/last.tar.gz"
        
        diff  = []
        diff << "cd #{root}"
        diff << "diff --text #{one} #{two} > data/#{uhash}/patch.dpf"
        diff << "rm #{two}"
        diff << "mv #{one} #{two}"
        diff << "cp #{two} #{repo}/first.tar.gz" if first
        %x[#{diff.join(";")}]
        
        unless first
            last  = []
            last << "cd #{repo}/#{list[list.keys[-1]]}"
            last << "echo '#{hash}' > next"
            last << "cd #{repo}/#{hash}"
            last << "echo '#{list[list.keys[-1]]}' > prev"
            %x[#{last.join(";")}]
        else
            prev  = []
            prev << "cd #{repo}/#{hash}"
            prev << "echo 'first' > prev"
            %x[#{prev.join(";")}]
        end
    end
end

def dwrm_pop here
    curr = here.split("/")[-1]
    root = File.expand_path(File.dirname(__FILE__))
    
    return unless directory_exists? ["#{root}/data","#{here}/.dwrm"]
    config = "#{here}/.dwrm/config.yml"
    conf = nil
    conf = File.open(config, "r").read if File.file?(config)
    return if conf.nil?
    conf = YAML.load(conf)
    uuid = conf[:uuid]
    list = Hash[conf[:list].sort]
    repo = "#{root}/data/#{uuid}"
    last = list[list.keys[-1]]
    past = list[list.keys[-2]]
    
    cmd  = []
    cmd << "cd .."
    cmd << "tar -czf #{curr}.tar.gz #{curr}/"
    cmd << "rm -rf #{curr}/"
    cmd << "patch #{curr}.tar.gz #{repo}/#{last}/patch.dpf"
    cmd << "tar -xzf #{curr}.tar.gz"
    cmd << "mv #{curr}.tar.gz #{repo}/last.tar.gz"
    cmd << "rm #{curr}.tar.gz*"
    cmd << "rm -rf #{repo}/#{last}"
    cmd << "rm #{repo}/#{past}/next" unless past.nil?
    %x[#{cmd.join(";")}]
    
    list.delete(list.keys[-1])
    conf[:list] = list
    File.open(config, "w"){|f| f.write(YAML.dump conf)}
end

def regex_cmd word
# Command regex generator

    return /^(-#{word[0]}$|(--#{word[0]}|#{word[0]})#{word[1..-1]}$)/
end

def parse_args
# Deal with arguments
    
    # Full path to current directory
    here = ENV["PWD"].sub("~", ENV["HOME"])
    
    # Only alpha commands may pass
    if /^(-[a-zA-Z]$|(--[a-zA-Z]|[a-zA-Z])[a-zA-Z]+?$)/ =~ ARGV[0]
        case ARGV[0]
        when "help" then help_docs()
        when "init"
            dir = "#{here}/.dwrm"
            unless directory_exists? [dir]
                FileUtils.mkdir_p(dir)
                set_configs(dir)
                
                puts "Initialized empty DataWorm repository in #{dir}"
            else 
                puts "DataWorm has already been initialized."
            end
        when "list"
            config = "#{here}/.dwrm/config.yml"
            if File.file? config
                conf = YAML.load File.open(config, "r").read
                list = Hash[conf[:list].sort]
                list.values.map{|hash| puts hash}
            end
        when "push"
            dwrm_push(here)
        when "pop"
            dwrm_pop(here)
        end
        
        no_care = ["help","list", "init"]
        if File.file?("#{here}/.dwrm/config.yml") and !no_care.include? ARGV[0]
            conf = File.open("#{here}/.dwrm/config.yml", "r").read
            conf = YAML.load(conf)
            conf[:hist] = ARGV[0]
            File.open("#{here}/.dwrm/config.yml", "w") do |f|
                f.write(YAML.dump conf)
            end
        end
    end
end

data = File.expand_path(File.dirname(__FILE__) + "/data")
unless directory_exists? [data]
    FileUtils.mkdir_p(data)
end

parse_args unless ARGV[0].nil?

# puts "\n+------------------+\n\n" 

# FileUtils.rm_rf ".dwrm"
